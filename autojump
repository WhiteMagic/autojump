#!/usr/bin/python
#This code is licensed under the GPL, version 3.
#A full copy of the license can be obtained by contacting the author at the following email adress: joel.schaerer@laposte.net
from __future__ import division

import os
import re
import sys
import signal
import optparse
import cPickle
import shutil


class PathDictionary:

    """
    Class representing the path lookup dictionary.

    Provides multiple methods to interact with the database.
    """

    def __init__(self, db_file="~/.autojump_py"):
        """Creates a new PathDictionary object.

        Populates the database from the given file, if it exists, else an empty
        database is used.
        """
        self.max_keyweight = 1000
        self.db_file = os.path.expanduser(db_file)
        try:
            with open(self.db_file, 'r') as f:
                self.db = cPickle.load(f)
        except IOError:
            self.db = {}

    def add(self, path, increment=1):
        """Increses the occurence counter of a path in the dictionary."""
        self.db[path] = self.db.get(path, 0.0) + increment
        self.save()

    def match(self, path):
        pass

    def save(self):
        """Stores the content of the PathDictionary to the filesystem."""
        cPickle.dump(self.db, open("%s.tmp" % self.db_file, 'w'), -1)
        # cPickle.dump doesn't seem to be atomic, so this is more secure
        shutil.copy("%s.tmp" % self.db_file, self.db_file)

    def status(self, mode="FREQ"):
        entries = self.db.items()
        if mode == "FREQ":
            entries.sort(key = lambda item:item[1])
        elif mode == "PATH":
            entries.sort(key = lambda item:item[1])
        for path, count in entries:
           print "%6.1f:\t%s" % (count, path)
        print "Total key weight: %d" % sum(self.db.values())

    def forget(self):
        """Gradually reduces the weight of entries."""
        keyweight = sum(self.db.values())
        if keyweight > self.max_keyweight:
            for key in self.db.iterkeys():
                self.db[key] *= 0.9 * self.max_keyweight / keyweight
        self.save()

    def find_matches(self, pattern, matches, mode, re_flags=0, max_matches=9):
        """Finds max_matches paths in the database that match the pattern.

        Returns a list containig the max_matches paths with the highes weight
        in the database.
        """
        entries = self.db.items()
        entries.sort(key = lambda item:item[1], reverse=True)
        for path, count in entries:
            if len(matches) >= max_matches:
                break
            if self.match(path, pattern, mode, re_flags):
                if path not in matches:
                    matches.append(path)

    def match(self, path, pattern, mode, re_flags=0):
        """Checks if the pattern occurs in the path.

        Returns true if a match is found, false otherwise.
        """
        if os.path.realpath(os.curdir) == path:
            return False
        if mode == "FULL":
            if re.search(pattern, path, re_flags) is None:
                return False
        elif mode == "END":
            source = "/".join(path.split('/')[-1-pattern.count('/'):])
            if re.search(pattern, source, re_flags) is None:
                return False
        if os.path.exists(path):
            return True
        else:
            # Remove entries from the database that no longer exist
            del self.db[path]
            return False

    def lookup(self, pattern, mode, completion=False):
        # 3 if the pattern is of the form __pattern__3, otherwise -1
        userchoice = -1
        results = []

        if not completion:
            self.forget()

        # If the pattern is a full match and a valid path return it
        if len(pattern) > 0 and pattern[0] == "/" and \
            os.path.exists(pattern) and not completion:
            return pattern
        else:
            endmatch = re.search("__([0-9]+)", pattern)
            if endmatch:
                userchoice = int(endmatch.group(1))
                pattern = re.sub("__[0-9]+.*", "", pattern)
            else:
                endmatch = re.match("(.*)__", pattern)
                if endmatch:
                    pattern = endmatch.group(1)

            # Find case sensitive partial matches
            self.find_matches(pattern, results, mode)
            # Find case insensitive partial matches if the previous search found
            # no matches, or completion is used.
            if completion or not results:
                self.find_matches(pattern, results, mode, re_flags=re.IGNORECASE)

            if userchoice != -1 and len(results) > userchoice-1:
                return results[userchoice-1]
            elif len(results) > 1 and completion:
                print "\n".join(("%s__%d__%s" % (pattern,n+1,r) for n,r in enumerate(results[:8])))
            else:
                if results:
                    return results[0]

def signal_handler(arg1,arg2):
    print "Received SIGINT, trying to continue"
signal.signal(signal.SIGINT,signal_handler) #Don't break on sigint

def uniqadd(list,key):
    if key not in list:
        list.append(key)

def dicadd(dic,key,increment=1):
    dic[key]=dic.get(key,0.)+increment

def match(path,pattern,path_dict,re_flags=0):
    import re
    if os.path.realpath(os.curdir)==path : return False
    if re.search(pattern,"/".join(path.split('/')[-1-pattern.count('/'):]),re_flags) is None:
        return False
    else: 
        if os.path.exists(path) : return True
        else: #clean up dead directories
            del path_dict[path]
            return False

def save(path_dict,dic_file):
    cPickle.dump(path_dict,open(dic_file+".tmp",'w'),-1)
    import shutil
    shutil.copy(dic_file+".tmp",dic_file) #cPickle.dump doesn't seem to be atomic, so this is more secure

def forget(path_dict,dic_file):
    """Gradually forget about directories. Only call from the actual jump since it can take time"""
    keyweight=sum(path_dict.values()) #Gradually forget about old directories
    if keyweight>max_keyweight: 
        for k in path_dict.keys():
            path_dict[k]*=0.9*max_keyweight/keyweight
    save(path_dict,dic_file)

def find_matches(dirs,pattern,path_dict,result_list,re_flags,max_matches):
    """Find max_matches paths that match the pattern, and add them to the result_list"""
    for path,count in dirs:
        if len(result_list) >= max_matches : break
        if match(path,pattern,path_dict,re_flags):
            uniqadd(result_list,path)

#Main code
try:
    optlist, args = getopt.getopt(argv[1:], 'a',['stat','import','completion']) 
except getopt.GetoptError, e:
    print "Unknown command line argument: %s" % e
    exit(1)

dic_file=os.path.expanduser("~/.autojump_py")
try:
    aj_file=open(dic_file)
    path_dict=cPickle.load(aj_file)
    aj_file.close()
except IOError:
    path_dict={}

if ('-a','') in optlist:
    dicadd(path_dict,args[-1])
    save(path_dict,dic_file)
elif ('--stat','') in optlist:
    a=path_dict.items()
    a.sort(key=lambda e:e[1])
    for path,count in a[-100:]:
        print "%.1f:\t%s" % (count,path)
    print "Total key weight: %d" % sum(path_dict.values())
elif ('--import','') in optlist:
    for i in open(args[-1]).readlines():
        dicadd(path_dict,i[:-1])
    cPickle.dump(path_dict,open(dic_file,'w'),-1)
else:
    import re
    completion=False
    userchoice=-1 #3 if the pattern is of the form __pattern__3, otherwise -1
    results=[]
    if ('--completion','') in optlist:
        completion=True
    else:
        forget(path_dict,dic_file) #gradually forget about old directories
    if not args: pattern=""
    else: pattern=args[-1]

    if len(pattern)>0 and pattern[0]=="/" and os.path.exists(pattern): #if pattern is a full path, jump there
        if not completion : print pattern
    else:
        endmatch=re.search("__([0-9]+)",pattern)
        if endmatch:
            userchoice=int(endmatch.group(1))
            pattern=re.sub("__[0-9]+.*","",pattern)
        else:
            endmatch=re.match("(.*)__",pattern)
            if endmatch: pattern=endmatch.group(1)

        dirs=path_dict.items()
        dirs.sort(key=lambda e:e[1],reverse=True)
        find_matches(dirs,pattern,path_dict,results,re_flags=0,max_matches=9)
        dirs=path_dict.items() #we need to recreate the list since the first iteration potentially deletes paths
        dirs.sort(key=lambda e:e[1],reverse=True)
        if completion or not results: #if not found, try ignoring case. On completion always show all results
            find_matches(dirs,pattern,path_dict,results,re_flags=re.IGNORECASE,max_matches=9) 

        if userchoice!=-1:
            if len(results) > userchoice-1 : print results[userchoice-1]
        elif len(results) > 1 and completion:
            print "\n".join(("%s__%d__%s" % (pattern,n+1,r) for n,r in enumerate(results[:8])))
        else: 
            if results : print results[0]
